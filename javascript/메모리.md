# 1. 자바스크립트 메모리 관리

c 와 같은 저수준 언어에서는 메모리 관리를 위해 특정 함수를 사용하는 반면, 자바스크립트는 객체가 생성되었을 때 자동으로 메모리를 할당하고 필요가 없어지면 `가비지 컬렉터`에 의해서 자동으로 해제된다.

하지만 이런 자동 메모리 시스템이 개발자가 메모리에 관해 고민할 필요가 없다는 것이 아니다.

## 1. 메모리 생존주기

> 1. 필요할때 할당
> 2. 사용한다 (읽기, 쓰기)
> 3. 필요없어지면 해제한다.

두번째 부분은 모든 언어에서 동일하게 시행된다.

그러나 첫 번째 부분과 마지막 부분은 저수준 언어에서는 명시적(직접 해야함)이고 고수준 언어에서는 암묵적(자동으로 해줌)으로 작동한다.

## 2. 자바스크립트에서의 메모리 할당

> 값 초기화

자바스크립트는 값을 선언할 때 자동으로 메모리를 할당한다.

```
var n = 123;
var s = 'azerty';
```

> 함수 호출을 통한 할당

함수 호출의 결과 메모리 할당이 일어나기도 한다

```
var d = new Date();

var e = document.createElement('div');
```

## 3. 값 사용

할당된 메모리를 읽고 쓰는일. 변수나 객체 속성의 값을 읽고 쓰거나 함수 호출시, 함수에 인수를 전달하는 일.

## 4. 할당된 메모리가 더이상 필요없을 때 해제하기

저수준 언어에서는 개발자가 직접 메모리 해제시점을 결정한다,
고수준 언어 (자바스크립트, 자바 등)에서는 가비지 콜렉터를 이용하여 메모리를 추적하고 할당된 메모리 블럭이 더 이상 필요하지 않게 되었는지 판단해 해제한다.

## 5. 가비지 콜렉션

> ### 참조-세기 (reference - count) 알고리즘

어떠한 다른 오브젝트도 참조하지 않는 오브젝트를 가비지라고 정의, 수집

> 예시
>
> ```
> var x = {
>  a: {
>    b: 2,
>  }
> };
>
> // 두개의 object 생성. 하나의 object는 다른 object의 속성으로 참조되었다.
> // 나머지 하나는 x 변수에 할당이 되었다.
> // 가비지 콜렉션이 될 메모리는 하나도 없다.
>
> var y = x; // y변수는 위의 오브젝트를 참조하는 두 번째 변수.
>
> x = 1; // 이제 y변수가 위의 오브젝트를 참조하는 유일한 변수
>
> var z = y.a; // 위의 오브젝트의 a 속성을 참조한다.
>              // y.a 는 z라는 변수가 참조하고 y가 속성으로 참조한다.
>
> y = 'mozilla'; // 이제 y는 위의 오브젝트를 참조하지 않는다.
>                // 이제 가비지 콜렉션이 수행될까?
>                // 아니다. 오브젝트의a 속성이 여전히 z변수를 참조하고 있어 메모리를 해제 할 수 없다.
>
> z = null;      // 이제는 맨처음 오브젝트를 참조하는 다른 변수나 속성이 없으므로 가비지 콜렉션이 수행된다.
> ```

한마디로 값이 사용(변수로써 참조가 되거나, 속성으로써 참조가 되거나)되면 가비지 콜렉션이 수집하지 않는다.

> ### 한계 => 순환참조

두 객체가 서로를 참조하는 방식으로 순환하게 되면 참조-세기 알고리즘의 대상이 되지 않아 함수호출이 끝나도 가비지 컬렉션의 대상으로 표시하지 않는다.

```
function f() {
  var x = {};
  var y = {};
  x.a = y;         // x는 y를 참조한다.
  y.a = x;         // y는 x를 참조한다.

  return "azerty";
}

f();
```
