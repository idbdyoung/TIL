# 비트 연산자 (bit otherwise operators)

| operator | name                  |
| -------- | --------------------- |
| &        | AND                   |
| \|       | OR                    |
| ^        | XOR                   |
| ~        | NOT                   |
| <<       | Zero fill left shift  |
| >>       | Signed Right shift    |
| >>>      | Zero fill right shift |

---

## & (AND) 비트 연산자

> 두개의 피연산자의 각자리마다 대응하는 비트가 1일 경우 1을 반환

```
const a = 5; // 0101
const b = 3; // 0011
a & b        // 0001 => 1;
```

참고

## | (OR) 비트 연산자

> 두개의 피연산자 중 하나 또는 두개모두 해당 비트가 1일 경우 1을 반환

```
const a = 5; // 0101
const b = 3; // 0011
a | b        // 0111 => 7;
```

## ^ (XOR) 비트 연산자

> 두개의 피연산자 중 하나의 해당 비트만이 1일 경우 1을 반환

```
const a = 5; // 0101
const b = 3; // 0011
a ^ b        // 0110 => 6
```

## ~ (NOT) 비트 연산자

> 피 연산자의 비트를 반전

```
const a = 5; // 00000000000000000000000000000101
~ a          // 11111111111111111111111111111010 => -6
```

## << (Left shift) 비트 연산자

> 첫번째 피연산자는 정수, 두번째 피연산자는 왼쪽으로 시프트 시킬 비트의 수

```
const a = 5; // 0000 0101
const b = 3;
a << 3       // 0010 1000 => 40
```

## >> (Right shift) 비트 연산자

> 첫번째 피연산자는 정수, 두번째 피연산자는 오른쪽으로 시프트 시킬 비트의 수

```
const a = 5; // 0000 0101
const b = 2;
a >> 3       // 0000 0001 => 1
```

## >>> (Unsigned rifht shift) 비트 연산자
